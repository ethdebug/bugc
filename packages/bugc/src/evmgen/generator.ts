/**
 * EVM Bytecode Generator
 *
 * Core code generation logic that transforms IR to EVM bytecode
 * with meticulous stack and memory management.
 */

import type {
  IrModule,
  IrFunction,
  BasicBlock,
  IrInstruction,
  Value,
  Terminator,
  PhiInstruction,
} from "../ir";
import { OPCODES, getPushOpcode, getDupOpcode } from "../evm";
import type {
  MemoryInfo,
  FunctionMemoryLayout as MemoryLayout,
} from "../memory/memory-planner";
import type {
  BlockInfo,
  FunctionBlockLayout as BlockLayout,
} from "../memory/block-layout";
import { EvmError, EvmErrorCode } from "./errors";

const MAX_STACK_DEPTH = 1024;
const MAX_DUP_REACH = 16;

interface GenState {
  /** Current stack contents (bottom to top) */
  stack: string[];
  /** Generated bytecode */
  bytes: number[];
  /** Memory layout for this function */
  memory: MemoryLayout;
  /** Patches needed for jump targets */
  patches: {
    offset: number;
    target: string;
    isPush2: boolean;
  }[];
  /** Current bytecode offset */
  offset: number;
}

/**
 * Get value ID for stack tracking
 */
function valueId(val: Value): string {
  if (val.kind === "const") {
    return `$${val.value}`;
  } else if (val.kind === "temp") {
    return val.id;
  } else {
    return val.name;
  }
}

/**
 * Emit bytes and return new state
 */
function emit(state: GenState, ...bytes: number[]): GenState {
  return {
    ...state,
    bytes: [...state.bytes, ...bytes],
    offset: state.offset + bytes.length,
  };
}

/**
 * Push a value onto the tracked stack
 */
function pushStack(state: GenState, id: string): GenState {
  if (state.stack.length >= MAX_STACK_DEPTH) {
    throw new EvmError(EvmErrorCode.STACK_OVERFLOW, `Pushing ${id}`);
  }
  return {
    ...state,
    stack: [...state.stack, id],
  };
}

/**
 * Pop a value from the tracked stack
 */
function popStack(state: GenState): [GenState, string] {
  if (state.stack.length === 0) {
    throw new EvmError(EvmErrorCode.STACK_UNDERFLOW);
  }
  const newStack = [...state.stack];
  const id = newStack.pop()!;
  return [{ ...state, stack: newStack }, id];
}

/**
 * Pop multiple values from stack
 */
function popMultiple(state: GenState, count: number): [GenState, string[]] {
  if (state.stack.length < count) {
    throw new EvmError(
      EvmErrorCode.STACK_UNDERFLOW,
      `Need ${count}, have ${state.stack.length}`,
    );
  }
  const newStack = [...state.stack];
  const popped: string[] = [];
  for (let i = 0; i < count; i++) {
    popped.push(newStack.pop()!);
  }
  return [{ ...state, stack: newStack }, popped.reverse()];
}

/**
 * Find position of value on stack (1-indexed from top)
 */
function findStackPosition(stack: string[], id: string): number {
  for (let i = stack.length - 1; i >= 0; i--) {
    if (stack[i] === id) {
      return stack.length - i;
    }
  }
  return -1;
}

/**
 * Convert bigint to bytes (big-endian)
 */
function bigintToBytes(value: bigint): number[] {
  if (value === 0n) return [];

  const hex = value.toString(16);
  const padded = hex.length % 2 ? "0" + hex : hex;
  const bytes: number[] = [];

  for (let i = 0; i < padded.length; i += 2) {
    bytes.push(parseInt(padded.substr(i, 2), 16));
  }

  return bytes;
}

/**
 * Emit PUSH instruction for a value
 */
function emitPush(state: GenState, value: bigint): GenState {
  if (value === 0n) {
    return emit(state, OPCODES.PUSH0);
  }

  const bytes = bigintToBytes(value);
  const opcode = getPushOpcode(bytes.length);
  return emit(state, opcode, ...bytes);
}

/**
 * Load a value to top of stack
 */
function loadValue(state: GenState, val: Value): GenState {
  if (val.kind === "const") {
    // Push constant
    const num = BigInt(val.value);
    const s1 = emitPush(state, num);
    return pushStack(s1, valueId(val));
  } else {
    const id = valueId(val);
    const stackPos = findStackPosition(state.stack, id);

    if (stackPos > 0 && stackPos <= MAX_DUP_REACH) {
      // Use DUP
      const s1 = emit(state, getDupOpcode(stackPos));
      return pushStack(s1, id);
    } else if (id in state.memory.allocations) {
      // Load from memory
      const offset = state.memory.allocations[id];
      const s1 = emitPush(state, BigInt(offset));
      // We don't track the offset on stack, just emit it
      const s2 = emit(s1, OPCODES.MLOAD);
      // MLOAD consumes offset and produces value
      return pushStack(s2, id);
    } else {
      throw new EvmError(
        EvmErrorCode.INVALID_STACK_ACCESS,
        `Cannot access value ${id}`,
      );
    }
  }
}

/**
 * Store a value to memory if allocated
 */
function storeToMemory(state: GenState, id: string): GenState {
  const offset = state.memory.allocations[id];
  if (offset === undefined) return state;

  // Stack: [value]
  const s1 = emitPush(state, BigInt(offset));
  // Stack: [value, offset]
  const s2 = emit(s1, OPCODES.DUP2);
  // Stack: [value, offset, value]
  const s3 = emit(s2, OPCODES.SWAP1);
  // Stack: [value, value, offset]
  const s4 = emit(s3, OPCODES.MSTORE);
  // Stack: [value]
  return s4;
}

/**
 * Generate code for a binary operation
 */
function generateBinaryOp(
  state: GenState,
  op: string,
  left: Value,
  right: Value,
  dest: string,
): GenState {
  // EVM LT/GT compare top < second and top > second respectively
  // With [left, right] on stack (right on top), LT checks right < left
  // But we want left < right, so we need to load them in reverse order
  const s1 = loadValue(state, right);
  const s2 = loadValue(s1, left);
  const [s3] = popMultiple(s2, 2);

  const opcodeMap: Record<string, number> = {
    add: OPCODES.ADD,
    sub: OPCODES.SUB,
    mul: OPCODES.MUL,
    div: OPCODES.DIV,
    mod: OPCODES.MOD,
    eq: OPCODES.EQ,
    ne: OPCODES.EQ, // Will NOT after
    lt: OPCODES.LT,
    gt: OPCODES.GT,
    le: OPCODES.GT, // Will NOT after
    ge: OPCODES.LT, // Will NOT after
    and: OPCODES.AND,
    or: OPCODES.OR,
  };

  const opcode = opcodeMap[op];
  if (opcode === undefined) {
    throw new EvmError(
      EvmErrorCode.UNSUPPORTED_INSTRUCTION,
      `Binary op: ${op}`,
    );
  }

  const s4 = emit(s3, opcode);

  // Handle inverted comparisons
  const s5 =
    op === "ne" || op === "le" || op === "ge" ? emit(s4, OPCODES.NOT) : s4;

  const s6 = pushStack(s5, dest);
  return storeToMemory(s6, dest);
}

/**
 * Generate code for an instruction
 */
function generateInstruction(state: GenState, inst: IrInstruction): GenState {
  let result: GenState;

  switch (inst.kind) {
    case "const": {
      const value = BigInt(inst.value);
      const s1 = emitPush(state, value);

      // If this value is memory-allocated and not needed on stack immediately,
      // store directly to memory without tracking on stack
      const memOffset = state.memory.allocations[inst.dest];
      if (memOffset !== undefined) {
        // Store directly to memory
        // MSTORE expects [value, offset] with offset on top of stack
        const s2 = emitPush(s1, BigInt(memOffset));
        // Stack after s2: [value, offset] - correct for MSTORE
        const s3 = emit(s2, OPCODES.MSTORE);
        // MSTORE consumes both value and offset, stack is now empty
        // We don't track this value on the stack since it's in memory
        result = s3;
      } else {
        // Keep on stack
        const s2 = pushStack(s1, inst.dest);
        result = s2;
      }
      break;
    }

    case "binary": {
      result = generateBinaryOp(
        state,
        inst.op,
        inst.left,
        inst.right,
        inst.dest,
      );
      break;
    }

    case "unary": {
      const s1 = loadValue(state, inst.operand);
      const [s2] = popStack(s1);

      let s3: GenState;
      if (inst.op === "not") {
        s3 = emit(s2, OPCODES.NOT);
      } else if (inst.op === "neg") {
        const s2a = emitPush(s2, 0n);
        s3 = emit(s2a, OPCODES.SUB);
      } else {
        throw new EvmError(
          EvmErrorCode.UNSUPPORTED_INSTRUCTION,
          `Unary op: ${inst.op}`,
        );
      }

      const s4 = pushStack(s3, inst.dest);
      result = storeToMemory(s4, inst.dest);
      break;
    }

    case "load_storage": {
      const s1 = loadValue(state, inst.slot);
      const s2 = emit(s1, OPCODES.SLOAD);
      const [s3] = popStack(s2);
      const s4 = pushStack(s3, inst.dest);
      result = storeToMemory(s4, inst.dest);
      break;
    }

    case "store_storage": {
      // SSTORE expects [key, value] on stack with key on top
      // So we need to load value first, then slot
      const s1 = loadValue(state, inst.value);
      const s2 = loadValue(s1, inst.slot);
      const s3 = emit(s2, OPCODES.SSTORE);
      const [s4] = popMultiple(s3, 2);
      result = s4;
      break;
    }

    case "env": {
      const envOpcodes: Record<string, number> = {
        msg_sender: OPCODES.CALLER,
        msg_value: OPCODES.CALLVALUE,
        msg_data: OPCODES.CALLDATASIZE,
        block_timestamp: OPCODES.TIMESTAMP,
        block_number: OPCODES.NUMBER,
      };

      const opcode = envOpcodes[inst.op];
      if (!opcode) {
        throw new EvmError(
          EvmErrorCode.UNSUPPORTED_INSTRUCTION,
          `Env var: ${inst.op}`,
        );
      }

      const s1 = emit(state, opcode);
      const s2 = pushStack(s1, inst.dest);
      result = storeToMemory(s2, inst.dest);
      break;
    }

    case "compute_slot": {
      // For mapping: keccak256(key || baseSlot)
      const s1 = loadValue(state, inst.key);
      const s2 = loadValue(s1, inst.baseSlot);

      // Store key at memory offset 0
      const s3 = emitPush(s2, 0n);
      const s4 = emit(s3, OPCODES.MSTORE);

      // Store baseSlot at memory offset 32
      const s5 = emitPush(s4, 32n);
      const s6 = emit(s5, OPCODES.MSTORE);

      // Hash 64 bytes starting at offset 0
      const s7 = emitPush(s6, 64n);
      const s8 = emitPush(s7, 0n);
      const s9 = emit(s8, OPCODES.KECCAK256);

      const [s10] = popMultiple(s9, 2);
      const s11 = pushStack(s10, inst.dest);
      result = storeToMemory(s11, inst.dest);
      break;
    }

    case "compute_array_slot": {
      // For arrays: keccak256(baseSlot)
      const s1 = loadValue(state, inst.baseSlot);
      // s1 has baseSlot on tracked stack

      // Store baseSlot at memory offset 0
      const s2 = emitPush(s1, 0n);
      const s3 = emit(s2, OPCODES.MSTORE);
      // MSTORE consumes [offset, value] from actual stack
      // We only have value tracked, so pop 1 from tracked stack
      const [s3a] = popStack(s3);

      // Hash 32 bytes starting at offset 0
      const s4 = emitPush(s3a, 32n);
      const s5 = emitPush(s4, 0n);
      const s6 = emit(s5, OPCODES.KECCAK256);
      // KECCAK256 consumes [offset, length] from actual stack, produces hash
      // We're not tracking offset/length, so just push the result
      const s7 = pushStack(s6, inst.dest);
      result = storeToMemory(s7, inst.dest);
      break;
    }

    case "hash": {
      const s1 = loadValue(state, inst.value);
      // For now, assume hash of 32 bytes
      const s2 = emitPush(s1, 32n);
      const s3 = emit(s2, OPCODES.KECCAK256);
      const [s4] = popMultiple(s3, 2);
      const s5 = pushStack(s4, inst.dest);
      result = storeToMemory(s5, inst.dest);
      break;
    }

    case "load_local": {
      // Local variables are stored in memory
      // The local variable should have been allocated memory
      const offset = state.memory.allocations[inst.local];
      if (offset === undefined) {
        throw new EvmError(
          EvmErrorCode.MEMORY_ALLOCATION_FAILED,
          `Local ${inst.local} not allocated in memory`,
        );
      }

      // Load from memory
      const s1 = emitPush(state, BigInt(offset));
      const s2 = emit(s1, OPCODES.MLOAD);
      const s3 = pushStack(s2, inst.dest);
      result = storeToMemory(s3, inst.dest);
      break;
    }

    case "store_local": {
      // Store value to local variable in memory
      // The local variable should have been allocated memory
      const offset = state.memory.allocations[inst.local];
      if (offset === undefined) {
        throw new EvmError(
          EvmErrorCode.MEMORY_ALLOCATION_FAILED,
          `Local ${inst.local} not allocated in memory`,
        );
      }

      // Load the value to store
      const s1 = loadValue(state, inst.value);

      // Store to memory: push offset, swap with value, MSTORE
      const s2 = emitPush(s1, BigInt(offset));
      const s3 = emit(s2, OPCODES.SWAP1);
      const s4 = emit(s3, OPCODES.MSTORE);

      // Pop the value from tracked stack
      const [s5] = popStack(s4);
      result = s5;
      break;
    }

    case "length": {
      // Length instruction - behavior depends on the type
      const objectType = inst.object.type;

      if (objectType.kind === "array") {
        if (objectType.size !== undefined) {
          // Fixed-size array - emit the constant
          const s1 = emitPush(state, BigInt(objectType.size));
          const s2 = pushStack(s1, inst.dest);
          result = storeToMemory(s2, inst.dest);
        } else {
          // Dynamic array - length is stored at the array's base slot
          const s1 = loadValue(state, inst.object);
          const s2 = emit(s1, OPCODES.SLOAD);
          const [s3] = popStack(s2);
          const s4 = pushStack(s3, inst.dest);
          result = storeToMemory(s4, inst.dest);
        }
      } else if (objectType.kind === "bytes") {
        if (objectType.size !== undefined) {
          // Fixed-size bytes - emit the constant
          const s1 = emitPush(state, BigInt(objectType.size));
          const s2 = pushStack(s1, inst.dest);
          result = storeToMemory(s2, inst.dest);
        } else {
          // Dynamic bytes - check if this is msg.data
          // For msg.data, the object would have been loaded via "env" instruction
          // and we'd need to track that somehow. For now, assume it's msg.data
          // if we see dynamic bytes (this is a simplification)
          const s1 = emit(state, OPCODES.CALLDATASIZE);
          const s2 = pushStack(s1, inst.dest);
          result = storeToMemory(s2, inst.dest);
        }
      } else if (objectType.kind === "string") {
        // Dynamic string - would need to load length from memory
        // For now, this is not fully implemented as we don't have
        // memory-based strings in the current system
        throw new EvmError(
          EvmErrorCode.UNSUPPORTED_INSTRUCTION,
          `length of string type not yet implemented`,
        );
      } else {
        throw new EvmError(
          EvmErrorCode.UNSUPPORTED_INSTRUCTION,
          `length operation not supported for type: ${objectType.kind}`,
        );
      }
      break;
    }

    // Add more instruction types as needed
    default:
      throw new EvmError(
        EvmErrorCode.UNSUPPORTED_INSTRUCTION,
        `Instruction: ${inst.kind}`,
      );
  }

  return result;
}

/**
 * Generate code for phi nodes
 */
function generatePhis(
  state: GenState,
  phis: PhiInstruction[],
  predecessor: string,
): GenState {
  return phis.reduce((s, phi) => {
    const source = phi.sources.get(predecessor);
    if (!source) {
      throw new EvmError(
        EvmErrorCode.PHI_NODE_UNRESOLVED,
        `Phi ${phi.dest} missing source from ${predecessor}`,
      );
    }

    // Load source value and store to phi destination
    const s1 = loadValue(s, source);
    const offset = s.memory.allocations[phi.dest];
    if (offset === undefined) {
      throw new EvmError(
        EvmErrorCode.MEMORY_ALLOCATION_FAILED,
        `Phi destination ${phi.dest} not allocated`,
      );
    }

    const s2 = emitPush(s1, BigInt(offset));
    const s3 = emit(s2, OPCODES.SWAP1);
    const s4 = emit(s3, OPCODES.MSTORE);
    const [s5] = popStack(s4);
    return s5;
  }, state);
}

/**
 * Generate code for a terminator
 */
function generateTerminator(
  state: GenState,
  term: Terminator,
  isLastBlock: boolean = false,
): GenState {
  switch (term.kind) {
    case "return": {
      const s1 = term.value ? loadValue(state, term.value) : state;
      // Only emit STOP if this isn't the last block (to prevent fall-through)
      // If it's the last block, execution will halt naturally
      return isLastBlock ? s1 : emit(s1, OPCODES.STOP);
    }

    case "jump": {
      const pushOffset = state.offset; // Save offset before emitting PUSH2

      // Placeholder PUSH2
      const s1 = emit(state, OPCODES.PUSH2, 0x00, 0x00);
      const s2 = emit(s1, OPCODES.JUMP);

      // Add patch for later resolution
      const newPatches = [
        ...s2.patches,
        {
          offset: pushOffset,
          target: term.target,
          isPush2: true,
        },
      ];

      return { ...s2, patches: newPatches };
    }

    case "branch": {
      const s1 = loadValue(state, term.condition);

      // For JUMPI to work correctly, we need [true_target, condition] on stack
      // But loadValue gives us [condition]
      // So: push true_target, then swap

      const truePush2Offset = s1.offset; // Save offset before emitting PUSH2
      const s2 = emit(s1, OPCODES.PUSH2, 0x00, 0x00); // push true_target
      const s3 = emit(s2, OPCODES.SWAP1); // now stack is [true_target, condition]
      const s4 = emit(s3, OPCODES.JUMPI); // jumps to true_target if condition != 0

      // If we're here, condition was false, so jump to false target
      const falsePush2Offset = s4.offset; // Save offset before emitting PUSH2
      const s5 = emit(s4, OPCODES.PUSH2, 0x00, 0x00); // push false_target
      const s6 = emit(s5, OPCODES.JUMP);

      // Add patches for both targets
      const newPatches = [
        ...s6.patches,
        {
          offset: truePush2Offset, // Location of first PUSH2 (true target)
          target: term.trueTarget,
          isPush2: true,
        },
        {
          offset: falsePush2Offset, // Location of second PUSH2 (false target)
          target: term.falseTarget,
          isPush2: true,
        },
      ];

      return { ...s6, patches: newPatches };
    }
  }
}

/**
 * Generate code for a basic block
 */
function generateBlock(
  state: GenState,
  block: BasicBlock,
  layout: BlockLayout,
  predecessor?: string,
  isLastBlock: boolean = false,
  isFirstBlock: boolean = false,
): GenState {
  // Mark block offset (mutates layout.offsets)
  layout.offsets.set(block.id, state.offset);

  // JUMPDEST at block start (except for the entry block with no predecessors)
  const skipJumpdest = isFirstBlock && block.predecessors.size === 0;
  let s = skipJumpdest ? state : emit(state, OPCODES.JUMPDEST);

  // Generate phi nodes if coming from a predecessor
  if (predecessor && block.phis.length > 0) {
    s = generatePhis(s, block.phis, predecessor);
  }

  // Generate instructions
  s = block.instructions.reduce(
    (acc, inst) => generateInstruction(acc, inst),
    s,
  );

  // Generate terminator
  return generateTerminator(s, block.terminator, isLastBlock);
}

/**
 * Patch jump targets after all blocks are generated
 */
function patchJumps(
  bytes: number[],
  patches: GenState["patches"],
  layout: BlockLayout,
): number[] {
  const result = [...bytes];

  for (const patch of patches) {
    const targetOffset = layout.offsets.get(patch.target);
    if (targetOffset === undefined) {
      throw new EvmError(
        EvmErrorCode.JUMP_TARGET_NOT_FOUND,
        `Target: ${patch.target}`,
      );
    }

    if (patch.isPush2) {
      // Write 2-byte address
      result[patch.offset + 1] = (targetOffset >> 8) & 0xff;
      result[patch.offset + 2] = targetOffset & 0xff;
    }
  }

  return result;
}

/**
 * Generate bytecode for a function
 */
export function generateFunction(
  func: IrFunction,
  memory: MemoryLayout,
  layout: BlockLayout,
): number[] {
  const initialState: GenState = {
    stack: [],
    bytes: [],
    memory,
    patches: [],
    offset: 0,
  };

  // Generate blocks in layout order
  const finalState = layout.order.reduce(
    (state: GenState, blockId: string, index: number) => {
      const block = func.blocks.get(blockId);
      if (!block) return state;

      // Determine predecessor for phi resolution
      // This is simplified - real implementation would track actual control flow
      const predecessor = index > 0 ? layout.order[index - 1] : undefined;

      // Check if this is the first or last block
      const isFirstBlock = index === 0;
      const isLastBlock = index === layout.order.length - 1;

      return generateBlock(
        state,
        block,
        layout,
        predecessor,
        isLastBlock,
        isFirstBlock,
      );
    },
    initialState,
  );

  // Patch jump targets
  return patchJumps(finalState.bytes, finalState.patches, layout);
}

export { generateModule } from "./typed-generator";

/**
 * Generate bytecode for entire module
 */
export function _generateModule(
  module: IrModule,
  memoryLayouts: MemoryInfo,
  blockLayouts: BlockInfo,
): { create?: number[]; runtime: number[] } {
  const result: { create?: number[]; runtime: number[] } = {
    runtime: [],
  };

  // Generate runtime
  const runtimeMemory = memoryLayouts["main"]!;
  const runtimeLayout = blockLayouts["main"]!;
  const runtimeBytes = generateFunction(
    module.main,
    runtimeMemory,
    runtimeLayout,
  );

  // Generate constructor bytecode
  let createBytes: number[] = [];

  if (module.create) {
    // Use the create function if present
    const memory = memoryLayouts["create"]!;
    const layout = blockLayouts["create"]!;
    createBytes = generateFunction(module.create, memory, layout);
  }

  // Helper to generate optimal PUSH instruction bytes
  const generatePush = (value: bigint): number[] => {
    if (value === 0n) {
      // Use PUSH1 0x00 for 0 (PUSH0 might not be available on all chains)
      return [OPCODES.PUSH1, 0x00];
    }

    const bytes = bigintToBytes(value);
    const opcode = getPushOpcode(bytes.length);
    return [opcode, ...bytes];
  };

  // Calculate deployment bytecode size iteratively
  // We need to know the size to calculate the offset, but the offset size affects the total size
  let deploymentPrefixSize = 0;
  let lastSize = -1;

  // Iterate until size stabilizes
  while (deploymentPrefixSize !== lastSize) {
    lastSize = deploymentPrefixSize;

    // Calculate size with current offset estimate
    const runtimeLengthBytes = generatePush(BigInt(runtimeBytes.length));
    const runtimeOffset = deploymentPrefixSize;
    const offsetBytes = generatePush(BigInt(runtimeOffset));

    deploymentPrefixSize =
      createBytes.length +
      runtimeLengthBytes.length + // PUSH runtime_length
      offsetBytes.length + // PUSH runtime_offset
      2 + // PUSH1 0x00
      1 + // CODECOPY
      runtimeLengthBytes.length + // PUSH runtime_length (again)
      2 + // PUSH1 0x00
      1; // RETURN
  }

  const runtimeOffset = deploymentPrefixSize;

  // Now build the actual bytecode with optimal PUSH opcodes
  const deploymentPrefix = [
    ...createBytes,
    // CODECOPY runtime to memory
    ...generatePush(BigInt(runtimeBytes.length)),
    ...generatePush(BigInt(runtimeOffset)),
    OPCODES.PUSH1,
    0x00,
    OPCODES.CODECOPY,
    // RETURN runtime
    ...generatePush(BigInt(runtimeBytes.length)),
    OPCODES.PUSH1,
    0x00,
    OPCODES.RETURN,
  ];

  const deployBytes = [...deploymentPrefix, ...runtimeBytes];

  result.create = deployBytes;
  result.runtime = runtimeBytes;
  return result;
}
